## Reactive Microservices with Eclipse Vert.x

In this section we will give an overview of Eclipse Vert.x and how you can build microservices using reactive principles.

In this section you will learn about building reactive microservies with Eclipse Vert.x and create a scalable API Gateway using reactive principle.


#### What is Eclipse Vert.x?
http://vertx.io[Eclipse Vert.x] is a toolkit for building reactive applications on the Java Virtual Machine (JVM). Vert.x does not 
impose a specific framework or packaging model and can be used within your existing applications and frameworks 
in order to add reactive functionaly by just adding the Vert.x jar files to the application classpath.

Vert.x enables building reactive systems as defined by http://www.reactivemanifesto.org/[The Reactive Manifesto] and build 
services that are:
* Responsive: to handle requests in a reasonable time
* Resilient: to stay responsive in the face of failures
* Elastic: to stay responsive under various loads and be able to scale up and down
* Message driven: components interact using asynchronous message-passing

Vert.x is designed to be event-driven and non-blocking. Events are delivered in an event loop that must never be blocked. Unlike traditional applications, Vert.x uses a very small number of threads responsible for dispatching the events to event handlers. If the event loop is blocked, the events won’t be delivered anymore and therefore the code needs to be mindful of this execution model.

#### Vert.x Maven Project 

* Included in your lab environment is Visual Studio Code, a lightweight IDE for editing projects. Load 
the `gateway-vertx` lab into the IDE by clicking on *File &rarr; Open* and choosing the
`gateway-vertx` folder.

* Once loaded, you should see the following files and be able to navigate amongst the files. The 
components of the Vert.x project are laid out in different subdirectories according to Maven best practices:

[source]
----
.
├── pom.xml
└── src
    ├── main
    │   └── java
    │   └── resources
    └── test
        └── resources
----

 * `src/main/java` - The source code to the project
 * `src/main/resources` - The static resource files and configurations
 * `src/test/resources` - The static resource files and configurations for testing
 * `pom.xml` - The Maven project file

* This is a minimal Vert.x project with support for RESTful services. This project currently contains no code
other than the main class, `GatewayVerticle.java` which is there to boostrap the Vert.x application. Verticles
are encapsulated parts of the application that can run completely independently and communicate with each other
via the built-in event bus in Vert.x. Verticles get deployed and run by Vert.x in an event loop and therefore it 
is important that the code in a Verticle does not block. This asynchronous architecture allows Vert.x applications 
to easily scale and handle large amounts of throughput with few threads.All API calls in Vert.x by default are non-blocking 
and support this concurrency model.

image::vertx-event-loop.jpg[Vert.x Event Loop,align=center]

Although you can have multiple, there is currently only one Verticle created in the `gateway-vertx` project. Examine 
`GatewayVerticle.java` in your IDE which:

[source,java]
----
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.ext.web.Router;

public class GatewayVerticle extends AbstractVerticle {
    @Override
    public void start(Future<Void> future) {
        Router router = Router.router(vertx);

        router.get("/*").handler(rc -> {
            rc.response().end("{\"message\": \"Hello World\"}");
        });

        vertx.createHttpServer().requestHandler(router::accept).listen(8080);
    }
}
----

Here is what happens in the above code:
* A Verticle is created by extending from `AbstractVerticle` class
* A `Router` is retrieved to mapping REST endpoints
* A REST endpoint is created for `/*` path and is mapped to the static JSON response `{"message": "Hello World"}`
* An HTTP Server is created which listens on port 8080

* You can use Maven to make sure the skeleton project builds successfully. You should get a `BUILD SUCCESS` message 
in the logs, otherwise the build has failed.

[source,bash]
----
$ cd projects/gateway-vertx
$ mvn package

...
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.769 s
[INFO] Finished at: 2017-07-28T11:44:11+07:00
[INFO] Final Memory: 20M/308M
[INFO] ----------------------------------------------------------------------------
----

* Once built, the resulting _jar_ is located in the `target/` directory:

[source,bash]
----
$ ls target/*.jar

target/gateway-1.0-SNAPSHOT.jar
----

* This is an uber-jar with all the dependencies required packaged in the _jar_ to enable runing the 
application with `java -jar`.

* You can run the Vert.x application using `java -jar` or conveniently using `vertx:run` goal from 
the `vertx-maven-plugin`:

[source,bash]
----
$ mvn vertx:run

...
[INFO] Starting vert.x application..
...
----

* Verify the application is working using `curl` in a new terminal window:

[source,bash]
----
$ curl http://localhost:8080

{"message": "Hello Vert.x"}
----

* Note that while the appliation is running using `mvn vertx:run`, you can make changes in the code
and they would immediately be compiled and updated in the running application to provide the fast
feedback to the developer.

* Now that the project is ready, let's get coding!

### Create the API Gateway

* In the previous labs, you have created two RESTful services: Catalog and Inventory. Instead of the 
web front contacting each of these backend services, you can create an API Gateway which is an entry 
point for for the web front to access all backend services from a single place. This pattern is expectecly 
called http://microservices.io/patterns/apigateway.html[API Gateway] and is a common practise in Microservices 
architecture.

image::vertx-gateway-arch.png[API Gateway Pattern,align=center]

* Replace the content of `GatewayVerticle` class with the following:

[source,java]
----
package com.redhat.cloudnative.gateway;

import io.vertx.core.*;
import io.vertx.core.http.*;
import io.vertx.core.json.*;
import io.vertx.ext.web.*;
import io.vertx.ext.web.handler.CorsHandler;

import java.util.List;
import java.util.stream.Collectors;

public class GatewayVerticle extends AbstractVerticle {
    private HttpClient client;

    @Override
    public void start(Future<Void> future) {
        client = vertx.createHttpClient();

        Router router = Router.router(vertx);
        router.route().handler(CorsHandler.create("*").allowedMethod(HttpMethod.GET));
        router.get("/api/products").handler(this::products);

        vertx.createHttpServer()
                .requestHandler(router::accept)
                .listen(config().getInteger("http.port", 8080), result -> {
                    if (result.succeeded()) {
                        future.complete();
                    } else {
                        future.fail(result.cause());
                    }
                });
    }

    private void products(RoutingContext rc) {
        client.getAbs(config().getString("inventory.url", "http://inventory:8080") + "/api/catalog", resp -> {
            if (resp.statusCode() == 200) {
                resp.bodyHandler(productBuff -> {
                    JsonArray products = new JsonArray(productBuff);
                    List<Future> inventory = products.stream()
                            .map(product -> inventory((JsonObject)product))
                            .collect(Collectors.toList());

                    CompositeFuture.join(inventory).setHandler(ar -> {
                        rc.response().end(Json.encodePrettily(products));
                    });
                });
            } else {
                rc.response().end(new JsonObject().put("error", "catalog: " + resp.statusMessage()).toString());
            }
        }).end();
    }

    private Future<Void> inventory(JsonObject product) {
        Future future = Future.future();

        client.getAbs(config().getString("catalog.url", "http://catalog:8080")
                + "/api/inventory/" + product.getString("itemId"), resp -> {
            if (resp.statusCode() == 200) {
                resp.bodyHandler(buff -> {
                    product.put("availability", 
                        new JsonObject().put("quantity", new JsonObject(buff).getInteger("quantity")));
                    future.complete();
                });
            } else {
                future.fail(resp.statusMessage());
            }
        }).end();

        return future;
    }
}
----

Let's break down what happens in the above code. The `start` method starts the Verticle, creates an HTTP server and a REST mapping to map `/api/products` to the `products` Java method

[source,java]
----
    @Override
    public void start(Future<Void> future) {
        client = vertx.createHttpClient();

        Router router = Router.router(vertx);
        router.route().handler(CorsHandler.create("*").allowedMethod(HttpMethod.GET));
        router.get("/api/products").handler(this::products);

        vertx.createHttpServer()
                .requestHandler(router::accept)
                .listen(config().getInteger("http.port", 8080), result -> {
                    ...
                });
    }
----

The `products` method invokes the Catalog REST endpoint and retrieves the products:

[source,java]
----
    private void products(RoutingContext rc) {
        client.getAbs(config().getString("inventory.url", "http://inventory:8080") + "/api/catalog", resp -> {
            if (resp.statusCode() == 200) {
                resp.bodyHandler(productBuff -> {
                    ....
                });
            } else {
                rc.response().end(new JsonObject().put("error", "catalog: " + resp.statusMessage()).toString());
            }
        }).end();
    }
----

The `products` method iterates over the retrieve products and for each product invokes the 
Inventory REST endpoint to get the inventry status and enrich the product data with availability 
info. Note that instead of making blocking calls to the Inventory REST endpoint, all calls 
are non-blocking and handled using http://vertx.io/docs/apidocs/io/vertx/core/Future.html[`Future`] objects. 
A `Future` object represents the result of an asynchronus action (e.g. calling a REST endpoint) with methods 
to check if the action is complete, succeeded or has failed. Vert.x Future concept is similar to the Future 
concept in Java which you can read more about them in this https://dzone.com/articles/javautilconcurrentfuture[blog post].

Due to its non-blocking nature, the `product` 
method can immediately return without waiting for the Inventory REST invocations to complete and whenever 
the result of the REST calls is ready, the defined handler (`CompositeFuture.join(inventory).setHandler(...)`) 
will act upon them and update the response which is then sent back to the client:

[source,java]
----
    private void products(RoutingContext rc) {
        ...
                resp.bodyHandler(productBuff -> {
                    JsonArray products = new JsonArray(productBuff);
                    List<Future> inventory = products.stream()
                            .map(product -> inventory((JsonObject)product))
                            .collect(Collectors.toList());

                    CompositeFuture.join(inventory).setHandler(ar -> {
                        rc.response().end(Json.encodePrettily(products));
                    });
                });
        ...
    }
----

The `inventory` method invokes the Inventory REST endpoint, retrieves the product inventory and 
enriches the product with the availability info:

[source,java]
----
    private Future<Void> inventory(JsonObject product) {
        Future future = Future.future();

        client.getAbs(config().getString("catalog.url", "http://catalog:8080")
                + "/api/inventory/" + product.getString("itemId"), resp -> {
            if (resp.statusCode() == 200) {
                resp.bodyHandler(buff -> {
                    product.put("availability", 
                        new JsonObject().put("quantity", new JsonObject(buff).getInteger("quantity")));
                    future.complete();
                });
            } else {
                future.fail(resp.statusMessage());
            }
        }).end();

        return future;
    }
}
----

* Run the maven build to make sure the code compiles successfully.

[source,bash]
----
$ mvn package
----

* Since the API Gateway requires the Catalog and Inventory services to be running, let's run all three 
services simultaneously and verify that the API Gateway works as expected. 

* Open a new terminal window and start the Catalog service:
[source,bash]
----
$ cd projects/catalog-spring-boot
$ mvn spring-boot:run
----

* Open a new terminal window and start the Inventory service:

[source,bash]
----
$ cd projects/inventory-wildfly-swarm
$ mvn wildfly-swarm:run
----

* Now that Catalog and Inventory services are up and running, start the API Gateway service in a new terminal window:

[source,bash]
----
$ cd projects/gateway-vertx
$ mvn vertx:run -Dvertx.config=src/test/resources/config.json
----

Note that a config file is provided to the Vert.x application to specify where the Catalog and 
Inventory service endpoints. In production, you will provide a different config file that provides
the production service coordinates.

* Now you can test the API Gatway by hitting the `/api/products` endpoint using `/curl`:

[source,bash]
----
$ curl http://localhost:8080/api/products

[ {
  "itemId" : "329299",
  "name" : "Red Fedora",
  "desc" : "Official Red Hat Fedora",
  "price" : 34.99,
  "availability" : {
    "quantity" : 35
  }
},
...
]
----

Note that the inventory info for each product is available within the same JSON object.

* Stop all services by pressing CTRL-C in the terminal windows.

### Deploy Spring Boot on OpenShift


* It’s time to build and deploy our service on OpenShift. First, make sure you are on the {{COOLSTORE_PROJECT}}:

[source,bash]
----
$ oc project {{COOLSTORE_PROJECT}}
----

* OpenShift {{OPENSHIFT_DOCS_BASE}}/architecture/core_concepts/builds_and_image_streams.html#source-build[Source-to-Image (S2I)] 
feature can be used to build a container image from your project. OpenShift 
S2I uses the supported OpenJDK container image to build the final container 
image of the API Gateway service by uploading the Vert.x uber-jar from 
the `target` folder to the OpenShift platform. 

* Maven projects can use the https://maven.fabric8.io[Fabric8 Maven Plugin] in order to use OpenShift S2I for building 
the container image of the application from within the project. This maven plugin is a Kubernetes/OpenShift client 
able to communicate with the OpenShift platform using the REST endpoints in order to issue the commands 
allowing to build aproject, deploy it and finally launch a docker process as a pod.

* To build and deploy the Inventory service on OpenShift using the `fabric8` maven plugin, run the following Maven command:

[source,bash]
----
$ mvn clean package fabric8:build fabric8:deploy
----

This will cause the following to happen:
[horizontal]
`clean`:: files generated at build-time in a project's directory are removed to reset to a clean state
`package`:: the API Gateway service uberjar is built using Vert.x
`fabric8:build`:: a docker image is built using OpenShift containing the API Gateway service uberjar and the Java runtime 
`fabric8:deploy`:: necessary objects are created within your OpenShift project to deploy the API Gateway service on OpenShift

* Once this completes, your project should be up and running. OpenShift runs the different components of 
the project in one or more pods which are the unit of runtime deployment and consists of the running 
containers for the project. 

* Get the route URL for the deployed API Gateway either using the OpenShift Web Console or the CLI:

[source,bash]
----
$ oc get routes

NAME        HOST/PORT                                                  PATH      SERVICES    PORT       TERMINATION   
catalog     catalog-coolstore.roadshow.openshiftapps.com               catalog     8080                     None
gateway     gateway-coolstore.roadshow.openshiftapps.com               gateway     8080                     None
inventory   inventory-coolstore.roadshow.openshiftapps.com             inventory   8080                     None
---

* Copy the route url for API Gateway and verify the API Gateway service works using 'curl'. Note that 
your route URLs would be different from the ones in this lab guide:

[source,bash]
----
$ curl http://API-GATEWAY-ROUTE-URL/api/products

[ {
  "itemId" : "329299",
  "name" : "Red Fedora",
  "desc" : "Official Red Hat Fedora",
  "price" : 34.99,
  "availability" : {
    "quantity" : 35
  }
},
...
]
----

* Well done! You are ready to move on to the next lab.