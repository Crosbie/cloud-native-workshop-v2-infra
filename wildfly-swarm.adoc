## Enterprise Microservices with WildFly Swarm

In this section we will give an overview of MicroProfile and how you can build microservices 
using WildFly Swarm. During this lab, you will create a REST API for the Inventory service in 
order to query the inventory status for each product.

#### What is WildFly Swarm?

Java EE applications are traditionally created as an `ear` or `war` archive including all 
dependencies and deployed in an application server. Multiple Java EE applications can and 
were typically deployed in the same application server. This model is well understood in 
the development teams and has been used over the past several years.

WildFly Swarm offers an innovative approach to packaging and running Java EE applications by 
packaging them with just enough of the Java EE server runtime to be able to run them directly 
on the JVM using `java -jar`. 

WildFly Swarm is based on WildFly and it's compatible with 
MicroProfile, which is a communnity effort to standardized the subset of Java EE standards 
such as JAX-RS, CDI and JSON-P that are useful for building microservices applications.

Since WildFly Swarm is based on Java EE standards, it significantly simplifies refactoring 
existing Java EE application to microservices and allows much of existing code-base to be 
reused in the new services.

#### WildFly Swarm Maven Project 

Included in your lab environment is Visual Studio Code, a lightweight IDE for editing projects. Load 
the `inventory-wildfly-swarm` lab into the IDE by clicking on *File &rarr; Open* and choosing the
`inventory-wildfly-swarm` folder.

Once loaded, you should see the following files and be able to navigate amongst the files. The 
components of the WildFly Swarm project are laid out in different subdirectories according to Maven best practices:

[source]
----
.
├── pom.xml              # The Maven project file
└── src
    └── main
        └── java         # The source code to the project
        └── resources    # The static resource files and configurations
----

TIP: WildFly Swarm projects can also be managed using other tools besides Maven, such as Gradle, JBoss Forge, or Swarmtool. Consult the https://wildfly-swarm.gitbooks.io/wildfly-swarm-users-guide/getting-started/tooling/forge-addon.html[docs] for more detail.

This is a minimal Java EE project with support for JAX-RS for building RESTful services and JPA for connecting
to a database. This project currently contains no code other than the main class for exposeing a single 
RESTful application defined in `InventoryApplication.java`. Examine `InventoryApplication.java` in your IDE:

[source,java]
----
package com.redhat.cloudnative.inventory;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/")
public class InventoryApplication extends Application {
}
----

You can use Maven to make sure the skeleton project builds successfully. You should get a `BUILD SUCCESS` message 
in the logs, otherwise the build has failed.

[source,bash]
----
$ cd projects/inventory-wildfly-swarm
$ mvn package

...
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 10.757 s
[INFO] Finished at: 2017-07-24T10:49:54+07:00
[INFO] Final Memory: 44M/481M
[INFO] ------------------------------------------------------------------------
----

Once built, the resulting _jar_ is located in the `target/` directory:

[source,bash]
----
$ ls target/*.jar
target/inventory-1.0-SNAPSHOT-swarm.jar
----

This is an uber-jar with all the dependencies required packaged in the _jar_ to enable runing the 
application with `java -jar`. WildFly Swarm also creates a _war_ packaiging as a standard Java EE web app 
that could be deployed to any Java EE app server (for example, JBoss EAP, or its upstream WildFly project).

Now let's write some code!

#### Create the Domain Model

Create a new Java class named `Inventory` in `com.redhat.cloudnative.inventory` package with the below code and 
following fields: `itemId` and `quantity`

[source,java]
----
package com.redhat.cloudnative.inventory;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import java.io.Serializable;

@Entity
@Table(name = "INVENTORY", uniqueConstraints = @UniqueConstraint(columnNames = "itemId"))
public class Inventory implements Serializable {
	@Id
    private String itemId;

    private int quantity;

    public Inventory() {
    }

    public String getItemId() {
        return itemId;
    }

    public void setItemId(String itemId) {
        this.itemId = itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Inventory [itemId='" + itemId + '\'' + ", quantity=" + quantity + ']';
    }
}
----

Review the `Inventory` domain model and note the JPA annotations on this class. `@Entity` marks 
the class as a JPA entity, `@Table` customizes the table creation process by defining a table 
name and database constraint and `@Id` marks the primary key for the table.

WildFly Swarm configuration is done to a large extend through detecting the intent of the 
developer and automatically adding the required dependencies configurations to make sure it can 
get out of the way and developers can be productive with their code rather than Googling for 
configuration snippets. As an example, configuration database access with JPA is composed of 
the following steps:

1. Add the `org.wildfly.swarm:jpa` dependency to `pom.xml` 
2. Add the database driver (e.g. `org.postgresql:postgresql`) to `pom.xml`
3. Add database connection details in `src/main/resources/project-defaults.yml`

Examine `pom.xml` and note the `org.wildfly.swarm:jpa` that is already added to enable JPA:

[source,xml]
----
    <dependency>
      <groupId>org.wildfly.swarm</groupId>
      <artifactId>jpa</artifactId>
    </dependency>
----

Examine `src/main/resources/META-INF/persistence.xml` to see the JPA datasource configuration for this project. Also note 
that the configurations uses `META-INF/load.sql` to import initial data into the database.

Examine `src/main/resources/project-defaults.yml` to see the database connection details. An in-memory H2 database is used 
in this lab for local development and in the following labs will be replaced with a PostgreSQL database. Be patient! More 
on that later.

#### Create a RESTful Service

WildFly Swarm uses JAX-RS standard for building REST services. Create a new Java class named `InventoryResource`
in `com.redhat.cloudnative.inventory` package with the following content:

[source,java]
----
package com.redhat.cloudnative.inventory;

import javax.enterprise.context.ApplicationScoped;
import javax.persistence.*;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/")
@ApplicationScoped
public class InventoryResource {
    @PersistenceContext(unitName = "InventoryPU")
    private EntityManager em;

    @GET
    @Path("/api/inventory/{itemId}")
    @Produces(MediaType.APPLICATION_JSON)
    public Inventory getAvailability(@PathParam("itemId") String itemId) {
        Inventory inventory = em.find(Inventory.class, itemId);
        return inventory;
    }
}
----

The above REST services defines an endpoint that is accessbile via `HTTP GET` at for example `/api/inventory/329299` with 
the last path param being the product id which we want to check its iventory status.

Build and package the Inventory service using Maven

[source,bash]
----
$ mvn package
----

Using WildFly Swarm maven plugin, you can conveniently run the application locally and test the endpoint.

[source,bash]
----
$ mvn wildfly-swarm:run
----

Alternatively, you can run the application using the uber-jar produced during the Maven build

[source,bash]
----
$ java -jar target/inventory-1.0-SNAPSHOT-swarm.jar
----

At this point, you can access the RESTful endpoint. Let’s test it out using `curl` in a new terminal window:

[source,bash]
----
$ curl http://localhost:9001/api/inventory/329299

{"itemId":"329299","quantity":736}
----

The RESTful endpoint returned a JSON object representing the inventory count for this product. Congratulations!

Stop the service by pressing CTRL-C in the terminal window.

#### Deploy WildFly Swarm on OpenShift

It’s time to build and deploy our service on OpenShift. First, make sure you are on the `{{COOLSTORE_PROJECT}}` project:

[source,bash]
----
$ oc project {{COOLSTORE_PROJECT}}
----

OpenShift {{OPENSHIFT_DOCS_BASE}}/architecture/core_concepts/builds_and_image_streams.html#source-build[Source-to-Image (S2I)] 
feature can be used to build a container image from your project. OpenShift 
S2I uses the supported OpenJDK container image to build the final container image of the 
Inventory service by uploading the WildFly Swam uber-jar from the `target` folder to 
the OpenShift platform. 

Maven projects can use the https://maven.fabric8.io[Fabric8 Maven Plugin] in order to use OpenShift S2I for building 
the container image of the application from within the project. This maven plugin is a Kubernetes/OpenShift client 
able to communicate with the OpenShift platform using the REST endpoints in order to issue the commands 
allowing to build aproject, deploy it and finally launch a docker process as a pod.

To build and deploy the Inventory service on OpenShift using the `fabric8` maven plugin, run the following Maven command:

[source,bash]
----
$ mvn fabric8:deploy
----

This will cause the following to happen:

* `clean` - files generated at build-time in a project's directory are removed to reset to a clean state
* `package` - the API Gateway service uberjar is built using Vert.x
* `fabric8:build` - a container image is built on OpenShift containing the service uberjar and JDK
* `fabric8:deploy` - necessary objects are created within the OpenShift project to deploy service

Once this completes, your project should be up and running. OpenShift runs the different components of 
the project in one or more pods which are the unit of runtime deployment and consists of the running 
containers for the project. 

TODO: explain resources created. oc get all? 

[source,bash]
----
$ oc get routes

NAME        HOST/PORT                                                  PATH      SERVICES    PORT       TERMINATION   
inventory   inventory-coolstore.roadshow.openshiftapps.com             inventory   8080                     None
----

Copy the route url for the Inventory service and verify the API Gateway service works using 'curl':

CAUTION: The route urls in your project would be different from the ones in this lab guide! Use the ones from yor project.

[source,bash]
----
$ curl http://INVENTORY-ROUTE-URL/api/inventory/329299

{"itemId":"329299","quantity":736}
----

Well done! You are ready to move on to the next lab.