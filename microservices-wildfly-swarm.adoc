## Enterprise Microservices with WildFly Swarm

In this section we will give an overview of MicroProfile and how you can build microservices 
using WildFly Swarm.

#### Lab Goals
In this lab you will create a REST API for the Inventory service in order to query the inventory status
for each product.

#### What is WildFly Swarm?
TBD

#### WildFly Swarm Maven Project 
* Included in your lab environment is Visual Studio Code, a lightweight IDE for editing projects. Load 
the `inventory-wildfly-swarm` lab into the IDE by clicking on *File &rarr; Open* and choosing the
`inventory-wildfly-swarm` folder.

* Once loaded, you should see the following files and be able to navigate amongst the files. The 
components of the WildFly Swarm project are laid out in different subdirectories according to Maven best practices:
 * `src/main/java` - The source code to the project
 * `src/main/resources` - The static resource files and configurations
 * `pom.xml` - The Maven project file

TIP: WildFly Swarm projects can also be managed using other tools besides Maven, such as 
Gradle, JBoss Forge, or Swarmtool. Consult the https://wildfly-swarm.gitbooks.io/wildfly-swarm-users-guide/content/v/2017.7.0/getting-started/tooling/forge-addon.html[docs] for more detail.

* This is a minimal Java EE project with support for JAX-RS for building RESTful services and JPA for connecting
to a database. This project currently contains no code other than the main class for exposeing a single 
RESTful application defined in `InventoryApplication.java`. Examine `InventoryApplication.java` in your IDE:

[source,java]
----
package com.redhat.cloudnative.inventory;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/")
public class InventoryApplication extends Application {
}
----

* You can use Maven to make sure the skeleton project builds successfully. You should get a `BUILD SUCCESS` message 
in the logs, otherwise the build has failed.

[source,bash]
----
$ cd $HOME/cloud-native-labs
$ mvn package

...
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 10.757 s
[INFO] Finished at: 2017-07-24T10:49:54+07:00
[INFO] Final Memory: 44M/481M
[INFO] ------------------------------------------------------------------------
----

* Once built, the resulting _war_ is located in the `target/` directory:

[source,bash]
----
$ ls target/*.jar
target/inventory-1.0-SNAPSHOT-swarm.war
----

* This is an uber-jar with all the dependencies required packaged in the _jar_ to enable runing the 
application with `java -jar`. WildFly Swarm also creates a _war_ packaiging as a standard Java EE web app 
that could be deployed to any Java EE app server (for example, JBoss EAP, or its upstream WildFly project).

* Now let's write some code!

### Create the Domain Model
* Create a new Java class named `Inventory` in `com.redhat.cloudnative.inventory` package with the below code and 
following fields: `itemId` and `quantity`

[source,java]
----
package com.redhat.cloudnative.inventory;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import java.io.Serializable;

@Entity
@Table(name = "INVENTORY", uniqueConstraints = @UniqueConstraint(columnNames = "itemId"))
public class Inventory implements Serializable {
	@Id
    private String itemId;

    private int quantity;

    public Inventory() {
    }

    public String getItemId() {
        return itemId;
    }

    public void setItemId(String itemId) {
        this.itemId = itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Inventory [itemId='" + itemId + '\'' + ", quantity=" + quantity + ']';
    }
}
----

* Review the `Inventory` domain model and note the JPA annotations on this class
 * `@Entity` - marks this class as a JPA entity
 * `@Table` - customizes the table creation process by defining a table name and database constraint
 * `@Id` - marks the primary key for the table

* WildFly Swarm configuration is done to a large extend through detecting the intent of the developer and automatically adding 
the required dependencies configurations to make sure it can get out of the way and developers can be productive with their code rather 
than Googling for configuration snippets. As an example, configuration database access with JPA is composed of the following 
steps:
 * Add a single `jpa` dependency to `pom.xml`
 * Define datasources in `META/persistent.xml`
 * Add database connection details in `src/main/resources/project-local.yml`

* WildFly Swarm uses JPA for accessing databases which is alrady enabled in this project via adding the `jpa` dependency to 
`pom.xml`. WildFly Swarm then automatically configures JPA, Hibernate and other required dependencies to be ready to use 
withing the project:

[source,xml]
----
    <dependency>
      <groupId>org.wildfly.swarm</groupId>
      <artifactId>jpa</artifactId>
    </dependency>
----

* Examine `src/main/resources/META-INF/persistence.xml` to see the JPA datasource configuration for this project. Also note 
that the configurations uses `META-INF/load.sql` to import initial data into the database.

### Create the REST Service

* WildFly Swarm uses JAX-RS standard for building REST services. Create a new Java class named `InventoryResource`
in `com.redhat.cloudnative.inventory` package with the following content:

[source,java]
----
package com.redhat.cloudnative.inventory;

import javax.enterprise.context.ApplicationScoped;
import javax.persistence.*;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/")
@ApplicationScoped
public class InventoryResource {
    @PersistenceContext(unitName = "MyPU")
    private EntityManager em;

    @GET
    @Path("/api/inventory/{itemId}")
    @Produces(MediaType.APPLICATION_JSON)
    public Inventory getAvailability(@PathParam("itemId") String itemId) {
        return em.find(Inventory.class, itemId);
    }
}
----

* The above REST services defines an endpoint that is accessbile via `HTTP GET` at for example `/api/inventory/329299` with 
the last path param being the product id which we want to check its iventory status.

* Build and package the inventory service using Maven

[source,bash]
----
$ mvn package
----

* Using WildFly Swarm plugin, you can conveniently run the application locally and test the endpoint.

[source,bash]
----
$ mvn wildfly-swarm:run
----

* Use `curl` to verify the REST endpoint works

[source,bash]
----
$ curl http://localhost:8080/api/inventory/329299

{"itemId":"329299","quantity":736}
----


TODO:
* Let's add a database now
* Create a new PostgreSQL database on OpenShift via the Web Console. Take note of the username and password
* Deploy on OpenShift and configure database
ConfigMap for project-stages?
Secrets for project-stages?
Env Vars?
